# Cucumber reference

Cucumber can be used to implement automated tests based on scenarios described in your Gherkin feature files.

## Step Arguments

In the example given in [step definitions](/docs/cucumber/step-definitions), Cucumber extracts the text `48` from the step, converts it to an `int`
and passes it as an argument to the <Term>stepdef-body</Term>.

The number of parameters in the <Term>stepdef-body</Term> has to match the number of <Term>expression-parameter</Term>s in the expression. (If there is a mismatch, Cucumber will throw an error).

## Data Tables

Data tables from Gherkin can be accessed by using the `DataTable` object as the last parameter in a step definition.
This conversion can be done either by Cucumber or manually.

<Tabs>
    <Tab value="java,kotlin,scala">

Depending on the table shape as one of the following collections:

```java
List<List<String>> table
List<Map<String, String>> table
Map<String, String> table
Map<String, List<String>> table
Map<String, Map<String, String>> table
```

    </Tab>
</Tabs>

The simplest way to pass a list of strings to a step definition is to use a data table:

```gherkin
Given the following animals:
  | cow   |
  | horse |
  | sheep |
```

<Tabs>
    <Tab value="java">

Declare the argument as a `List<String>` but don't define any capture group in the expression.

Annotated method style:

```java
@Given("the following animals:")
public void the_following_animals(List<String> animals) {
}
```

In this case, the `DataTable` is automatically flattened to a list of strings by Cucumber (using `DataTable.asList(String.class)`) before invoking the step definition.

In addition to collections of `String`, `Integer`, `Float`, `BigInteger` and `BigDecimal`, `Byte`,
`Short`, `Long` and `Double` are also supported.

See also [cucumber-jvm data-tables](https://github.com/cucumber/cucumber-jvm/tree/main/cucumber-java#data-tables).

    </Tab>
    <Tab value="kotlin">

Declare the argument as a `List<String>` but don't define any capture group in the expression.

Annotated method style:

```kotlin
@Given("the following animals:")
fun the_following_animals(animals: List<String>) {
}
```

In this case, the `DataTable` is automatically flattened to a list of strings by Cucumber (using `DataTable.asList(String.class)`) before invoking the step definition.

In addition to collections of `String`, `Integer`, `Float`, `BigInteger` and `BigDecimal`, `Byte`,
`Short`, `Long` and `Double` are also supported.

See also [cucumber-jvm data-tables](https://github.com/cucumber/cucumber-jvm/tree/main/cucumber-java#data-tables).

    </Tab>
    <Tab value="scala">

```scala
Given("the following animals:") { animals: java.util.List[String] =>
}
```

In this case, the `DataTable` is automatically flattened to a list of strings by Cucumber (using `DataTable.asList(String.class)`) before invoking the step definition.

For now, Cucumber Scala does not support using Scala collection types, see [this issue](https://github.com/cucumber/cucumber-jvm-scala/issues/50).

    </Tab>
</Tabs>

For an example of data tables in JavaScript, go [here](https://github.com/cucumber/cucumber-js/blob/master/src/models/data_table.ts)

## Steps

A step is analogous to a method call or function invocation.

For example:

```gherkin
Given I have 93 cucumbers in my belly
```

In this step, you're "calling" the above step definition with one argument: the value `93`.

Steps are declared in your `*.feature` files.

### Matching steps

1. Cucumber matches a step against a step definition's `Regexp`
2. Cucumber gathers any <Term>expression-parameter</Term>s or variables
3. Cucumber passes them to the step definition's <Term>stepdef-body</Term> and executes it

Recall that step definitions start with a [preposition](https://www.merriam-webster.com/dictionary/given) or an [adverb](https://www.merriam-webster.com/dictionary/when) (**`Given`**, **`When`**, **`Then`**, **`And`**, **`But`**).

All step definitions are loaded (and defined) before Cucumber starts to execute the plain text in the feature file.

Once execution begins, for each step, Cucumber will look for a registered step definition with a matching `Regexp`. If it finds one, it will execute it, passing all <Term>expression-parameter</Term>s and variables from the Regexp as arguments to the <Term>stepdef-body</Term>.

The specific preposition/adverb used has **no** significance when Cucumber is registering or looking up step definitions.

Also, check out [multiline step arguments](/docs/gherkin/reference#step-arguments) for more info on how to pass entire tables or bigger strings to your step definitions.

### Step Results

Each step can have one of the following results:

#### Success

When Cucumber finds a matching step definition it will execute it. If the block in the step definition doesn't raise an error, the step is marked as successful (green). Anything you `return` from a step definition has no significance whatsoever.

#### Undefined

When Cucumber can't find a matching step definition, the step gets marked as undefined (yellow), and all subsequent steps in the scenario are skipped.

#### Pending

When a step definition's <Term>stepdef-body</Term> invokes the `pending` <Term>stepdef-body</Term>, the step is marked as pending (yellow, as with `undefined` ones), indicating that you have work to do.

#### Failed Steps

When a step definition's <Term>stepdef-body</Term> is executed and raises an error, the step is marked as failed (red). What you return from a step definition has no significance whatsoever.

Returning `null`, `false` or some other falsy value in your programming language will **not** cause a step definition to fail.

#### Skipped

Steps that follow `undefined`, `pending`, or `failed` steps are never executed, even if there is a matching step definition. These steps are marked as skipped (cyan).

#### Ambiguous

Step definitions have to be unique for Cucumber to know what to execute. If more than one step definition is matched for the same step, Cucucmber can't resolve the ambiguity on its own. The behaviour varies a bit between implementations:

<Tabs>
    <Tab value="java,kotlin,scala">Cucumber will throw an `AmbiguousStepDefinitionsException`.</Tab>
    <Tab value="javascript">Cucumber will report an AMBIGUOUS result status.</Tab>
    <Tab value="ruby">Cucumber will raise a `Cucumber::Ambiguous` error.</Tab>
</Tabs>

## Hooks

Hooks are blocks of code that can run at various points in the Cucumber execution cycle.
They are typically used for setup and teardown of the environment before and after each scenario.

Where a hook is defined has no impact on what scenarios or steps it is run for.
If you want more fine-grained control, you can use [conditional hooks](#conditional-hooks).

<Tabs>
    <Tab value="java,kotlin">You can declare hooks in any class.</Tab>
    <Tab value="scala">You can declare hooks in any class, trait or object.</Tab>
    <Tab value="javascript">You can declare hooks in your `features/support/env.js` file, or any other file under the `features/support` directory (for example, in a file called `features/support/hooks.js`).</Tab>
    <Tab value="ruby">You can declare hooks in your `features/support/env.rb` file, or any other file under the `features/support` directory (for example, in a file called `support/hooks.rb`).</Tab>
</Tabs>

### Scenario hooks

Scenario hooks run for every scenario.

#### Before

`Before` hooks run before the first step of each scenario.

<Tabs>
    <Tab value="java">

Annotated method style:

```java
@Before
public void doSomethingBefore() {
}
```

Lambda style:

```java
Before(() -> {
});
```

    </Tab>
    <Tab value="kotin">

Lambda style:

```kotlin
Before { scenario: Scenario ->
    // doSomething
}
```

    </Tab>
    <Tab value="scala">

```scala
Before { scenario: Scenario =>
    // doSomething
}
```

    </Tab>
    <Tab value="javascript">

```javascript
// Import the Before function
const { Before } = require('@cucumber/cucumber')

Before(async function () {
})
```

:::warning[Avoid arrow functions]
Arrow functions (`() => {}`) bind `this` to the current context, which prevents sharing state between hooks and step definitions.
:::

    </Tab>
    <Tab value="ruby">

```ruby
Before do
  # Do something before each scenario
end
```

    </Tab>
</Tabs>

:::tip[Think twice before you use `Before`]
Whatever happens in a `Before` hook is invisible to people who only read the features.
You should consider using a [background](/docs/gherkin/reference#background) as a more explicit
alternative, especially if the setup should be readable by non-technical people.
Only use a `Before` hook for low-level logic such as starting a browser or deleting
data from a database.
:::

<Tabs>
    <Tab value="java">

You can specify an explicit order for hooks if you need to.

Annotated method style:

```java
@Before(order = 10)
public void doSomething(){
    // Do something before each scenario
}
```

Lambda style:

```java
Before(10, () -> {
    // Do something before each scenario
});
```

    </Tab>
    <Tab value="kotlin">

You can specify an explicit order for hooks if you need to.

```kotlin
Before(10) { scenario: Scenario ->
    // Do something before each scenario
}
```
:::warning[Using Kotlin named objects or companion objects]

If `@BeforeAll`, `@AfterAll` etc. are used in Kotlin named objects or companion objects an `io.cucumber.java.InvalidMethodSignatureException`
will be thrown, as Kotlin will create a class `MyStepDefinitions$Companion` which has non-static methods. [Read more about it here](https://kotlinlang.org/docs/java-to-kotlin-interop.html#static-methods).

The `@JvmStatic` annotation does not prevent this behaviour of Kotlin; it adds the static methods to `MyStepDefinitionsMethod` only.

Consequently, Cucumber will detect the static methods in `MyStepDefinitions` class, as well as the non-static methods in `MyStepDefinitions$Companion` class and will complain about the second one.

As a solution to this problem, use [ package level functions](https://kotlinlang.org/docs/java-to-kotlin-interop.html#package-level-functions) - this is, without companion objects.
:::

```kotlin
package io.cucumber.example

import io.cucumber.java.AfterAll
import io.cucumber.java.BeforeAll

@BeforeAll
fun beforeAll() {
   println("before all")
}

@AfterAll
fun afterAll() {
   println("after all")
}
```

    </Tab>
    <Tab value="scala">

You can specify an explicit order for hooks if you need to.

```scala
Before(10) { scenario: Scenario =>
    // Do something before each scenario
}
```

    </Tab>
    <Tab value="javascript,ruby">`Before` hooks run in the **same order** in which they are declared.</Tab>
</Tabs>

#### After

`After` hooks run after the last step of each scenario, even when the step result is `failed`, `undefined`, `pending`, or `skipped`.

<Tabs>
    <Tab value="java">

Annotated method style:

```java
@After
public void doSomethingAfter(Scenario scenario){
    // Do something after after scenario
}
```

Lambda style:

```java
After((Scenario scenario) -> {
});
```

    </Tab>
    <Tab value="kotlin">

Lambda style:

```kotlin
After { scenario: Scenario ->
    // doSomething
}
```

    </Tab>
    <Tab value="scala">

```scala
After { scenario: Scenario =>
    // doSomething
}
```

    </Tab>
    <Tab value="javascript">

```javascript
After(async function (scenario) {
})
```

    </Tab>
    <Tab value="ruby">

```ruby
After do |scenario|
end
```

Here is an example in which we exit at the first failure (which could be useful in some cases like [Continuous Integration](/docs/guides/continuous-integration), where fast feedback is important).

```ruby
After do |s|
  # Tell Cucumber to quit after this scenario is done - if it failed.
  Cucumber.wants_to_quit = true if s.failed?
end
```

    </Tab>
</Tabs>

The `scenario` parameter is optional. If you use it, you can inspect the status of the scenario.

For example, you can take a screenshot for failed scenarios and embed them in Cucumber's report(s); see the [browser automation page](/docs/guides/browser-automation/#screenshot-on-failure) for an example on how to do so.

#### Around

:::warning[Ruby only]
Only the Ruby implementation of Cucumber supports `Around` hooks.
:::

`Around` hooks will run "around" a scenario. This can be used to wrap the execution of a scenario in a block. The `Around` hook receives a `Scenario` object and a block (`Proc`) object. The scenario will be executed when you invoke `block.call`.

The following example will cause scenarios tagged with `@fast` to fail if the execution takes longer than 0.5 seconds:

```ruby
Around('@fast') do |scenario, block|
  Timeout.timeout(0.5) do
    block.call
  end
end
```

### Step hooks

Step hooks are invoked before and after a step. The hooks have "invoke around" semantics, meaning that if a `BeforeStep`
hook is executed the `AfterStep` hooks will also be executed regardless of the result of the step. If a step did not
pass, the following step and its hooks will be skipped.

#### BeforeStep

<Tabs>
    <Tab value="java">

Annotated method style:

```java
@BeforeStep
public void doSomethingBeforeStep(Scenario scenario){
}
```

Lambda style:

```java
BeforeStep((Scenario scenario) -> {

});
```

    </Tab>
    <Tab value="kotlin">

Lambda style:

```kotlin
BeforeStep { scenario: Scenario ->
    // doSomething
}
```

    </Tab>
    <Tab value="scala">

```scala
BeforeStep { scenario: Scenario =>
    // doSomething
}
```

    </Tab>
    <Tab value="javascript">

```javascript
BeforeStep(async function({pickle, pickleStep, gherkinDocument, testCaseStartedId, testStepId}) {
    // doSomething
})

BeforeStep({tags: "@foo"}, async function() {
    // apply this hook to only specific scenarios
})
```

    </Tab>
    <Tab value="ruby">Cucumber-Ruby does not support `BeforeStep` hooks.</Tab>
</Tabs>

#### AfterStep

<Tabs>
    <Tab value="java">

Annotated method style:

```java
@AfterStep
public void doSomethingAfterStep(Scenario scenario){
}
```

Lambda style:

```java
AfterStep((Scenario scenario) -> {
});
```

    </Tab>
    <Tab value="kotlin">

Lambda style:

```kotlin
AfterStep { scenario: Scenario ->
    // doSomething
}
```

    </Tab>
    <Tab value="scala">

```scala
AfterStep { scenario: Scenario =>
    // doSomething
}
```

    </Tab>
    <Tab value="javascript">

```javascript
AfterStep(async function({pickle, pickleStep, gherkinDocument, result, testCaseStartedId, testStepId}) {
    // doSomething
})
```

    </Tab>
    <Tab value="ruby">

```ruby
AfterStep do |scenario|
end
```

    </Tab>
</Tabs>